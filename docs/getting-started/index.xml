<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DELL Technologies â€“ Installation</title><link>https://sakshimakkar.github.io/hugo1/docs/getting-started/</link><description>Recent content in Installation on DELL Technologies</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://sakshimakkar.github.io/hugo1/docs/getting-started/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Installation using Common helm Installer</title><link>https://sakshimakkar.github.io/hugo1/docs/getting-started/helm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sakshimakkar.github.io/hugo1/docs/getting-started/helm/</guid><description>
&lt;h2 id="installation-scripts-and-readmemd-files">Installation scripts and README.md files&lt;/h2>
&lt;p>The scripts and documentation are located within the &lt;a href="installer">installer&lt;/a> directory. These scripts are designed
to be placed within the CSI Driver repos in a directory called &lt;code>/dell-csi-helm-installer&lt;/code> and require the driver helm chart
to be located within the &lt;code>/helm&lt;/code> directory of the same repo.&lt;/p>
&lt;h2 id="copying-the-scripts-to-target-driver-repos">Copying the scripts to target driver repos&lt;/h2>
&lt;p>A helper script is available that will copy the common installer scripts and docuemtnation to each driver. This script can be found at &lt;code>util/update-driver.sh&lt;/code>
and will perform the following steps for each driver:&lt;/p>
&lt;ul>
&lt;li>Clone the driver repo&lt;/li>
&lt;li>Either checkout or create a branch for the changes to be applied to. If the user supplied branch name exists, it will be used. If it does not exist,
one will be created.&lt;/li>
&lt;li>Copy the common installer scripts to the target branch&lt;/li>
&lt;li>Copy the documentation to the target branch. While copying, it will substitute:&lt;/li>
&lt;li>The driver arrays formal name (PowerMax, PowerFlex, PowerStore, PowerScale, Unity) for any text matching __PROPERPRODUCTNAME__&lt;/li>
&lt;li>The driver arrays informal name, always in lower case (powermax, vxflexos, powerstore, isilon, unity) for text matching __LOWERPRODUCTNAME__&lt;/li>
&lt;li>After each file is copied, a &lt;code>git diff&lt;/code> will be performed so the user can inspect the changes and validate them&lt;/li>
&lt;li>Once all files are copied, the files will be added to a &lt;code>git commit&lt;/code> with a commit message that has been supplied by the user.&lt;/li>
&lt;li>At this stage, if there are any changes, the user will be prompted if they would like to &lt;code>git push&lt;/code> the changes to the git remote&lt;/li>
&lt;li>If the &lt;code>git push&lt;/code> is successful, the script can automatically create a PR in the target repository, if one does not exist. If the user elects to not create a PR, one can be created manually.&lt;/li>
&lt;/ul>
&lt;p>A video demonstrating the use of the &lt;code>util/update-driver.sh&lt;/code> script has been made, It can be accessed (Passcode: ftju8Np*) at &lt;a href="https://Dell.zoom.us/rec/share/qAOiNw3PSy1TtHBuzI9R6hN3W1PfZr_w8rKVk5X8Zg1axQqjYNYKG89mabbIkeef.9pLpkZfdJ3kEGKq4">https://Dell.zoom.us/rec/share/qAOiNw3PSy1TtHBuzI9R6hN3W1PfZr_w8rKVk5X8Zg1axQqjYNYKG89mabbIkeef.9pLpkZfdJ3kEGKq4&lt;/a>&lt;/p>
&lt;p>This script will create a temporary working directory that must be manually cleaned up. The location of this directory will be displayed at the end of the script.&lt;/p>
&lt;p>Help is available for this script&lt;/p>
&lt;pre>&lt;code>[dell-csi-helm-installer]# update-driver.sh -h
Help for update-driver.sh
This script will copy the Common Helm Installer scripts to a branch within each driver and push them to the remote
Usage: update-driver.sh options...
--directory[=]&amp;lt;directory&amp;gt; Directory to copy files from.
Default is &amp;quot;/dell/git/dell-csi-helm-installer/installer&amp;quot;
--branch[=]&amp;lt;branch&amp;gt; Branch to copy to. This branch will be created if it does not exist at the remote.
Default is &amp;quot;feature/update-common-installer-scripts&amp;quot;
--commit[=]&amp;lt;commit message&amp;gt; Git commit message.
Default is &amp;quot;Addressing installation review comments across all drivers&amp;quot;
--assume-yes Assume 'yes' for any questions. Default is not to assume this.
-h Help
&lt;/code>&lt;/pre></description></item><item><title>Docs: Installation using Operator</title><link>https://sakshimakkar.github.io/hugo1/docs/getting-started/operator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sakshimakkar.github.io/hugo1/docs/getting-started/operator/</guid><description>
&lt;h2 id="description">Description&lt;/h2>
&lt;p>&lt;code>dell-csi-operator&lt;/code> is a Kubernetes operator which can be used to install and manage various CSI Drivers provided by Dell EMC for different storage arrays.&lt;/p>
&lt;p>It is built, deployed and tested using the toolset provided by Operator &lt;a href="https://github.com/operator-framework">framework&lt;/a> which include:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/operator-framework/operator-sdk">operator-sdk&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/operator-framework/operator-lifecycle-manager">operator-lifecycle-manager&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/operator-framework/operator-registry">operator-registry&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Note - &lt;strong>operator-sdk-vv1.18.2-x86_64-linux-gnu&lt;/strong> has been used to build the &lt;code>dell-csi-operator&lt;/code> and is available at the root of the repository&lt;/p>
&lt;h2 id="custom-resource-definitions">Custom Resource Definitions&lt;/h2>
&lt;p>&lt;code>dell-csi-operator&lt;/code> manages a set of &lt;a href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/">Custom Resource Definitions&lt;/a> (CRDs)&lt;br>
These CRDs represent a specific CSI Driver installation and are part of the API group &lt;code>storage.dell.com&lt;/code>&lt;br>
The current set of CRDs managed by the &lt;code>dell-csi-operator&lt;/code> are:&lt;/p>
&lt;ul>
&lt;li>CSIUnity&lt;/li>
&lt;li>CSIIsilon&lt;/li>
&lt;li>CSIVXFlexOS&lt;/li>
&lt;li>CSIPowerStore&lt;/li>
&lt;li>CSIPowerMax&lt;/li>
&lt;li>CSIPowerMaxRevProxy&lt;/li>
&lt;/ul>
&lt;h2 id="controllers">Controllers&lt;/h2>
&lt;p>&lt;code>dell-csi-operator&lt;/code> utilizes Kubernetes &lt;a href="https://github.com/kubernetes-sigs/controller-runtime">controller runtime&lt;/a> libraries for building controllers which
run as part of the Operator deployment.&lt;br>
These controllers watch for any requests to create/modify/delete instances of the Custom Resource Definitions (CRDs) and handle the &lt;a href="https://godoc.org/sigs.k8s.io/controller-runtime/pkg/reconcile">reconciliation&lt;/a>
of these requests.&lt;/p>
&lt;p>Each instance of a CRD is called a Custom Resource (CR) and can be managed by a client like &lt;code>kubectl&lt;/code> in the same way a native
Kubernetes resource is managed.&lt;br>
When you create a Custom Resource, then the corresponding Controller will create the Kubernetes objects required for the driver installation.&lt;/p>
&lt;p>This includes:&lt;/p>
&lt;ul>
&lt;li>Service Accounts and RBAC configuration&lt;/li>
&lt;li>StatefulSet&lt;/li>
&lt;li>DaemonSet&lt;/li>
&lt;li>Deployment and Service (only for CSIPowerMaxRevProxy)&lt;/li>
&lt;/ul>
&lt;p>Note - There is one controller per Custom Resource type and each controller runs a single worker&lt;/p>
&lt;h2 id="build-and-deploy">Build and Deploy&lt;/h2>
&lt;h3 id="pre-requisites">Pre-requisites&lt;/h3>
&lt;p>Make sure you are running the build on a machine with go &lt;strong>1.13.x&lt;/strong> installed&lt;/p>
&lt;p>There are multiple Makefile targets available for building the Operator&lt;/p>
&lt;h3 id="building-operator-binary">Building Operator binary&lt;/h3>
&lt;p>If you wish to build the Operator binary, run the command - &lt;code>make go-build&lt;/code>&lt;/p>
&lt;h3 id="build-operator-image">Build Operator image&lt;/h3>
&lt;p>There are a few available Makefile targets which let you build a docker image for the Operator.
The docker image is built using the &lt;code>operator-sdk&lt;/code> binary (which is available in the repository).
The base image used to build the docker image is UBI (Universal Base Image) provided by Red Hat.&lt;/p>
&lt;p>Run the command &lt;code>make docker-local&lt;/code> to make a docker image for the operator which will be tagged
with the current logged in user and a timestamp. This option is useful for multiple developers using the same testing environment&lt;/p>
&lt;p>Run the command &lt;code>make docker&lt;/code> to build a docker image for the Operator which will be tagged with git semantic versioning&lt;br>
The official builds of Operator which are hosted on artifactory are built using the &lt;code>make docker&lt;/code> command&lt;/p>
&lt;p>By default, this target will tag the newly built images with the artifactory repo&lt;br>
Run the command &lt;code>REGISTRY=my-image-repo/dell-csi-operator make docker&lt;/code> to tag the docker image with your own repository&lt;/p>
&lt;h3 id="push-docker-image-to-private-repository">Push docker image to private repository&lt;/h3>
&lt;p>Run the command &lt;code>REGISTRY=my-image-repo/dell-csi-operator make docker-push&lt;/code> to build and push the docker image to &lt;code>my-image-repo&lt;/code> private repository&lt;/p>
&lt;h3 id="push-docker-image-to-artifactory">Push docker image to artifactory&lt;/h3>
&lt;p>Run the command &lt;code>make docker-push&lt;/code> to build and push the docker image to the artifactory repository for Operator&lt;/p>
&lt;p>Note - Don&amp;rsquo;t use this option unless you really wish to push the image to artifactory as it may end up overwriting official builds&lt;/p>
&lt;h3 id="run-the-operator-locally-without-deploying-any-image">Run the Operator locally without deploying any image&lt;/h3>
&lt;h4 id="pre-requisites-1">Pre-requisites&lt;/h4>
&lt;p>Make sure that a &lt;a href="https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/">&lt;strong>KubeConfig&lt;/strong>&lt;/a> file pointing to your Kubernetes/OpenShift cluster is present in the default location&lt;/p>
&lt;p>Run either of the following commands to run the Operator in your cluster without creating a deployment&lt;/p>
&lt;ul>
&lt;li>&lt;code>make go-run&lt;/code>&lt;/li>
&lt;li>&lt;code>./operator-sdk run local&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Note - Make sure to install the CRDs managed by the Operator before running it locally&lt;/p>
&lt;p>The above command will run the Operator binary which will be equivalent to installing the operator in the default namespace&lt;/p>
&lt;h4 id="deploy-the-operator">Deploy the operator&lt;/h4>
&lt;p>There are primarily two ways of deploying the Operator -&lt;/p>
&lt;ol>
&lt;li>Use Operator manifests and installation scripts&lt;/li>
&lt;li>Use &lt;a href="https://github.com/operator-framework/operator-lifecycle-manager">OLM&lt;/a> to install the Operator&lt;br>
During development -&lt;br>
a) Use internal Operator Catalog hosted on artifactory&lt;br>
b) Use OperatorHub to deploy publicly available Operator&lt;/li>
&lt;/ol>
&lt;h3 id="deploy-operator-without-olm">Deploy Operator without OLM&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Update the docker image in the file &lt;code>deploy/operator.yaml&lt;/code> to the one you wish to install&lt;br>
This could be an image from artifactory, an image which you built or any public image on dockerhub&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Run the command &lt;code>bash scripts/install.sh&lt;/code> to deploy the Operator in the default namespace&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The installation script does the following:&lt;/p>
&lt;ul>
&lt;li>Create a Service Account and setup the RBAC using ClusterRole and ClusterRoleBindings&lt;/li>
&lt;li>Create a ConfigMap which is used by the Operator&lt;/li>
&lt;li>Install the various CRDs managed by the Operator&lt;/li>
&lt;li>Create the Operator deployment (single replica)&lt;/li>
&lt;/ul>
&lt;h3 id="deploy-operator-using-olm">Deploy Operator using OLM&lt;/h3>
&lt;h4 id="pre-requisites-2">Pre-requisites&lt;/h4>
&lt;p>&lt;a href="https://github.com/operator-framework/operator-lifecycle-manager">OLM&lt;/a> is not available on upstream Kubernetes cluster by default and has to be installed before installing the Operator.&lt;/p>
&lt;p>Run the command &lt;code>./operator-sdk olm install&lt;/code> to install &lt;code>OLM&lt;/code> in your cluster&lt;/p>
&lt;p>Note - OLM is available as a default component in OpenShift clusters and you don&amp;rsquo;t need to install it separately&lt;/p>
&lt;p>Note - Please refer Operator SDK &lt;a href="https://sdk.operatorframework.io/docs/">documentation&lt;/a> for more help on using operator-sdk&lt;/p>
&lt;h4 id="deploy-operator-using-internal-catalog">Deploy Operator using internal Catalog&lt;/h4>
&lt;p>Run the command &lt;code>bash scripts/install_olm.sh&lt;/code> to install the Operator using OLM in an upstream Kubernetes cluster
Run the command &lt;code>bash scripts/install_olm.sh --openshift&lt;/code> to install the Operator using OLM in an OpenShift cluster&lt;/p>
&lt;p>The above scripts will create instances of the following CRDs:&lt;/p>
&lt;ul>
&lt;li>CatalogSource&lt;/li>
&lt;li>OperatorGroup&lt;/li>
&lt;li>Subscription&lt;/li>
&lt;li>InstallPlan&lt;/li>
&lt;li>ClusterServiceVersion&lt;/li>
&lt;/ul>
&lt;p>You can query the status of these objects in the &lt;code>test-olm&lt;/code> namespace to get more information or troubleshoot any issues found during installation.&lt;/p>
&lt;h3 id="verify-installation">Verify Installation&lt;/h3>
&lt;p>Post a successful installation of the Operator, there should be an Operator deployment created in the cluster.&lt;br>
Depending on the method of installation, this would be created in the namespace:&lt;/p>
&lt;ul>
&lt;li>Installation without OLM - &lt;code>default&lt;/code>&lt;/li>
&lt;li>Installation with OLM - &lt;code>test-olm&lt;/code>&lt;/li>
&lt;/ul>
&lt;h4 id="query-for-crds">Query for CRDs&lt;/h4>
&lt;p>You can also query for the CRDs installed in the cluster by running the command
&lt;code>kubectl get crd&lt;/code>. You should see the following CRDs in the list of CRDs installed in the cluster:&lt;/p>
&lt;ul>
&lt;li>csiisilons.storage.dell.com&lt;/li>
&lt;li>csipowermaxes.storage.dell.com&lt;/li>
&lt;li>csipowermaxrevproxies.storage.dell.com&lt;/li>
&lt;li>csipowerstores.storage.dell.com&lt;/li>
&lt;li>csiunities.storage.dell.com&lt;/li>
&lt;li>csivxflexoses.storage.dell.com&lt;/li>
&lt;/ul>
&lt;h2 id="install-a-csi-driver">Install a CSI driver&lt;/h2>
&lt;p>Once the CRDs and Operator has been installed in the cluster, you can install any CSI driver by creating a Custom Resource (CR)&lt;br>
For e.g. - If you want to install the CSI PowerMax driver, you should create a CR of the Kind &lt;code>CSIPowerMax&lt;/code>&lt;/p>
&lt;p>Here are the steps involved in installing a driver:&lt;/p>
&lt;ul>
&lt;li>Make sure all dependencies for the driver have been met. This can include installation of specific packages, configuration of services, nodes&lt;/li>
&lt;li>Create the namespace where you wish to install the driver&lt;/li>
&lt;li>Create any mandatory and optional secrets required for the driver installation&lt;/li>
&lt;li>Create the Custom Resource using the sample manifests provided for the driver&lt;/li>
&lt;/ul>
&lt;h3 id="create-custom-resource">Create custom resource&lt;/h3>
&lt;p>A lot of sample manifest files have been provided in the &lt;code>deploy/crd&lt;/code> folder to help with the installation of various CSI Drivers
They follow the naming convention&lt;/p>
&lt;pre>&lt;code>{driver name}_{driver version}_k8s_{k8 version}.yaml
&lt;/code>&lt;/pre>
&lt;p>Or&lt;/p>
&lt;pre>&lt;code>{driver name}_{driver version}_ops_{OpenShift version}.yaml
&lt;/code>&lt;/pre>
&lt;p>Use the correct sample manifest based on the driver, driver version and Kubernetes/OpenShift version&lt;/p>
&lt;p>For e.g.&lt;br>
powermax_v140_k8s_117.yaml &amp;lt;- To install CSI PowerMax driver v1.4.0 on a Kubernetes 1.17 cluster
powermax_v140_ops_43.yaml &amp;lt;- To install CSI PowerMax driver v1.4.0 on an OpenShift 4.3 cluster&lt;/p>
&lt;p>Note - For this example, we will assume that the Custom Resource will be created in the namespace &lt;code>powermax&lt;/code> with the name &lt;code>powermax&lt;/code>&lt;/p>
&lt;p>Create a new file &lt;code>powermax.yaml&lt;/code> by copying the relevant sample file and edit the contents (specific to your installation).&lt;/p>
&lt;p>Run the command &lt;code>kubectl create -f powermax.yaml&lt;/code> to create the Custom Resource (CR)&lt;/p>
&lt;p>Check the status of the Custom Resource by running the command &lt;code>kubectl get csipowermax -n powermax&lt;/code>&lt;/p>
&lt;p>If the status of the CR shows &lt;code>Running&lt;/code> then the driver installation completed successfully with all driver pods running&lt;br>
If the status of the CR shows &lt;code>Succeeded&lt;/code> then the driver installation succeeded but all driver pods are not up and running&lt;br>
If the status of the CR shows &lt;code>InvalidConfig&lt;/code> then there is an incorrect value specified in the Custom Resource manifest&lt;/p>
&lt;p>Note - The driver status can take some time to migrate from &lt;code>Succeeded&lt;/code> to &lt;code>Running&lt;/code> because of the time taken for the driver pods to completely start up.&lt;br>
In case some pods are not up and running, the Operator will query for their status for at least an hour before giving up on updating the status of the Custom Resource.&lt;/p>
&lt;p>You can also check the status of the driver pods by running the command &lt;code>kubectl get pods -n powermax&lt;/code>&lt;/p>
&lt;p>Note - Run the command &lt;code>kubectl get csipowermax --all-namespaces&lt;/code> to query for all Custom Resources of the type CSIPowerMax in your cluster&lt;/p>
&lt;h3 id="update-custom-resource">Update Custom Resource&lt;/h3>
&lt;p>If you want to update the driver installation or fix any issues in the Custom Resource (for e.g. - InValidConfig), then you can update the Custom Resource&lt;br>
This can be done in multiple ways&lt;/p>
&lt;ul>
&lt;li>Run the command &lt;code>kubectl edit csipowermax powermax -n powermax&lt;/code> and edit any desired field(s)&lt;/li>
&lt;li>Update the manifest file and run the command &lt;code>kubectl apply -f powermax.yaml&lt;/code>&lt;/li>
&lt;li>Directly patch the Custom Resource (refer Kubernetes documentation)&lt;/li>
&lt;/ul>
&lt;p>Once the update has been applied to the Custom Resource, the Operator will try to &lt;code>reconcile&lt;/code> the desired state with the observed state in the cluster and apply required changes (if any) to the various resources part of the driver installation&lt;/p>
&lt;h3 id="delete-custom-resource">Delete Custom Resource&lt;/h3>
&lt;p>Run the command &lt;code>kubectl delete -f powermax.yaml&lt;/code> to delete the Custom Resource. This will delete the Custom Resource and delete all the driver pods.&lt;/p></description></item><item><title>Docs: Installation process of specific driver</title><link>https://sakshimakkar.github.io/hugo1/docs/getting-started/driver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sakshimakkar.github.io/hugo1/docs/getting-started/driver/</guid><description/></item></channel></rss>